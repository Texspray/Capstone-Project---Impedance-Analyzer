/* ******************************************************
 * main.cpp
 * Central de Comando do Analisador de Impedância (v2.13 - Estável)
 *
 * - GANHO DO PGA CORRIGIDO: de volta para PGA_GAIN_X1 (como no Arduino).
 * - Autoinicialização de hardware (DAC, Pot, Muxes).
 * - Comandos "calibrate", "sweep", "config", "setconfig".
 * - Lógica de MUX independente (uma porta por MUX).
 * - Impressão "Human-Readable" (identificada).
 * ****************************************************** */

// --- Includes ---
#include <stm32f4xx_hal.h>
#include <stm32f4xx_hal_uart.h>
#include <stm32f4xx_hal_i2c.h>
#include <stm32f4xx_hal_pwr_ex.h> 
#include <stdio.h>
#include <string.h>
#include <stdlib.h> // Para atoi, atol
#include <math.h>
#include "AD5933.h"

// --- Constantes de Limite ---
#define MAX_INCREMENTS 100 // Tamanho MÁXIMO dos arrays
#define TX_BUFFER_SIZE 100
#define RX_BUFFER_SIZE 100

// --- Parâmetros de Varredura (Variáveis Globais com valores padrão) ---
unsigned long g_start_freq = 1000;
unsigned long g_freq_incr  = 1000;
int           g_num_incr   = 99;
long          g_ref_resist = 1000;

// Endereços I2C (já com shift para o HAL)
#define AD5252_ADDRESS    (0x2D << 1) // Potenciômetro
#define ADG728_ADDRESS    (0x4C << 1) // MUX 1
#define ADG728_ADDRESS2   (0x4E << 1) // MUX 2
#define MCP4725_ADDRESS   (0x61 << 1) // DAC
#define AD5252_CMD_RDAC1  (0x01)

// --- Variáveis Globais ---
UART_HandleTypeDef huart2;
I2C_HandleTypeDef  hi2c1;
char    tx_buffer[TX_BUFFER_SIZE];
char    rx_buffer[RX_BUFFER_SIZE];
volatile uint8_t rx_index = 0;
volatile bool command_ready = false;
uint8_t rx_byte_it;

// Arrays Globais (usando o MÁXIMO)
int real[MAX_INCREMENTS];
int imag[MAX_INCREMENTS];
double gain[MAX_INCREMENTS];
double phase[MAX_INCREMENTS];

// --- Protótipos de Funções ---
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_USART2_UART_Init(void);
static bool MX_I2C1_Init(void);
extern "C" void Error_Handler(void);
extern "C" void USART2_IRQHandler(void);
extern "C" void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);
void send_uart_string(const char* str);
bool setDAC(uint16_t value);
bool setPot(uint8_t value);
bool setMux1(uint8_t value);
bool setMux2(uint8_t value);
void runCalibration(void);
void runSweep(void);
void parseCommand(char* cmd);
void printConfig(void);


/**
  * @brief  Ponto de entrada principal
  */
int main(void)
{
  HAL_Init();
  SystemClock_Config(); 
  MX_GPIO_Init();
  MX_USART2_UART_Init();

  HAL_Delay(2000); // Espera o Monitor Serial conectar
  
  send_uart_string("\r\n\r\n--- Analisador de Impedancia STM32 v2.13 (Estavel) ---\r\n");

  if (MX_I2C1_Init()) 
  {
    send_uart_string("I2C OK. Configurando hardware padrao...\r\n");
    
    // Configura hardware padrão (como no .ino)
    setPot(190);
    setDAC(2048);
    setMux1(0x08); // Liga MUX 1, Porta 4 (bitmask 8)
    setMux2(0x10); // Liga MUX 2, Porta 5 (bitmask 16)
  }
  else
  {
    send_uart_string("FALHA CRITICA: HAL_I2C_Init() falhou. Verifique o hardware.\r\n");
  }
  
  send_uart_string("------------------------------------------\r\n");
  printConfig(); // Mostra a configuração padrão
  send_uart_string("Pronto. Envie 'calibrate' ou 'sweep'.\r\n");

  HAL_UART_Receive_IT(&huart2, &rx_byte_it, 1);

  while (1)
  {
    HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5); // Pisca LENTO (500ms)
    HAL_Delay(500); 

    if (command_ready)
    {
      parseCommand(rx_buffer);
      command_ready = false;
    }
  }
}

// -----------------------------------------------------------------
// --- FUNÇÕES DE LÓGICA (PORTADAS DO .INO) ---
// -----------------------------------------------------------------

/**
 * @brief Processa a string de comando vinda do PC
 */
void parseCommand(char* cmd)
{
  char* arg;
  arg = strchr(cmd, ','); // Tenta encontrar o primeiro argumento/vírgula
  if (arg) {
    *arg = '\0'; // Separa o comando do argumento
    arg++;
  }

  // --- Comandos de Ação ---
  if (strcmp(cmd, "calibrate") == 0)
  {
    runCalibration();
  }
  else if (strcmp(cmd, "sweep") == 0)
  {
    runSweep();
  }
  else if (strcmp(cmd, "config") == 0)
  {
    printConfig();
  }
  
  // --- Comando SetConfig (Multi-argumento) ---
  else if (strcmp(cmd, "setconfig") == 0 && arg)
  {
    char* sfreq_s = strtok(arg, ",");
    char* fincr_s = strtok(NULL, ",");
    char* nincr_s = strtok(NULL, ",");
    char* rref_s  = strtok(NULL, ",");

    if (sfreq_s && fincr_s && nincr_s && rref_s)
    {
      g_start_freq = (unsigned long)atol(sfreq_s);
      g_freq_incr  = (unsigned long)atol(fincr_s);
      int n = atoi(nincr_s);
      g_ref_resist = (long)atol(rref_s);

      if (n >= MAX_INCREMENTS) {
        sprintf(tx_buffer, "FALHA: NUM_INCR (%d) deve ser < %d\r\n", n, MAX_INCREMENTS);
        send_uart_string(tx_buffer);
      } else {
        g_num_incr = n;
        send_uart_string("OK: Nova configuracao completa recebida.\r\n");
        printConfig();
      }
    }
    else
    {
      send_uart_string("FALHA: Formato incorreto. Use: setconfig,sfreq,fincr,nincr,rref\r\n");
    }
  }

  // --- Comandos de Configuração de Varredura (Individuais) ---
  else if (strcmp(cmd, "sfreq") == 0 && arg)
  {
    g_start_freq = (unsigned long)atol(arg);
    sprintf(tx_buffer, "OK: START_FREQ = %lu Hz\r\n", g_start_freq);
    send_uart_string(tx_buffer);
  }
  else if (strcmp(cmd, "fincr") == 0 && arg)
  {
    g_freq_incr = (unsigned long)atol(arg);
    sprintf(tx_buffer, "OK: FREQ_INCR = %lu Hz\r\n", g_freq_incr);
    send_uart_string(tx_buffer);
  }
  else if (strcmp(cmd, "nincr") == 0 && arg)
  {
    int n = atoi(arg);
    if (n >= MAX_INCREMENTS) {
      sprintf(tx_buffer, "FALHA: NUM_INCR deve ser < %d\r\n", MAX_INCREMENTS - 1);
    } else {
      g_num_incr = n;
      sprintf(tx_buffer, "OK: NUM_INCR = %d\r\n", g_num_incr);
    }
    send_uart_string(tx_buffer);
  }
  else if (strcmp(cmd, "rref") == 0 && arg)
  {
    g_ref_resist = (long)atol(arg);
    sprintf(tx_buffer, "OK: REF_RESIST = %ld Ohm\r\n", g_ref_resist);
    send_uart_string(tx_buffer);
  }

  // --- Comandos de Configuração de Hardware ---
  else if (strcmp(cmd, "dac") == 0 && arg)
  {
    uint16_t value_16 = (uint16_t)atoi(arg);
    if (setDAC(value_16)) sprintf(tx_buffer, "OK: DAC reconfigurado para: %u\r\n", value_16);
    else sprintf(tx_buffer, "FALHA: DAC nao respondeu.\r\n");
    send_uart_string(tx_buffer);
  }
  else if (strcmp(cmd, "pot") == 0 && arg)
  {
    uint8_t value_8 = (uint8_t)atoi(arg);
    if (setPot(value_8)) sprintf(tx_buffer, "OK: Potenciometro reconfigurado para: %u\r\n", value_8);
    else sprintf(tx_buffer, "FALHA: Potenciometro nao respondeu.\r\n");
    send_uart_string(tx_buffer);
  }

  // --- Lógica de MUX Corrigida (Independente) ---
  else if (strcmp(cmd, "mux1") == 0 && arg)
  {
    uint8_t porta = (uint8_t)atoi(arg); // Recebe o NÚMERO da porta (0-8)
    uint8_t bitmask;

    if (porta == 0) { bitmask = 0; }
    else if (porta > 8) { bitmask = 0; porta = 0; }
    else { bitmask = 1 << (porta - 1); } // Converte (ex: Porta 4 -> 1 << 3 -> 8)

    if (setMux1(bitmask)) sprintf(tx_buffer, "OK: MUX 1 ativou Porta %u (bitmask: 0x%02X)\r\n", porta, bitmask);
    else sprintf(tx_buffer, "FALHA: MUX 1 nao respondeu.\r\n");
    send_uart_string(tx_buffer);
  }
  else if (strcmp(cmd, "mux2") == 0 && arg)
  {
    uint8_t porta = (uint8_t)atoi(arg); // Recebe o NÚMERO da porta (0-8)
    uint8_t bitmask;

    if (porta == 0) { bitmask = 0; }
    else if (porta > 8) { bitmask = 0; porta = 0; }
    else { bitmask = 1 << (porta - 1); } // Converte (ex: Porta 5 -> 1 << 4 -> 16)
      
    if (setMux2(bitmask)) sprintf(tx_buffer, "OK: MUX 2 ativou Porta %u (bitmask: 0x%02X)\r\n", porta, bitmask);
    else sprintf(tx_buffer, "FALHA: MUX 2 nao respondeu.\r\n");
    send_uart_string(tx_buffer);
  }
  
  // --- Comandos de Teste do AD5933 ---
  else if (strcmp(cmd, "status") == 0)
  {
    uint8_t status_reg = AD5933::readStatusRegister();
    sprintf(tx_buffer, "AD5933 Status Register (0x8F) = 0x%02X\r\n", status_reg);
    send_uart_string(tx_buffer);
  }
  else if (strcmp(cmd, "reset") == 0)
  {
    if (AD5933::reset()) send_uart_string("AD5933 resetado.\r\n");
    else send_uart_string("Falha no reset do AD5933.\r\n");
  }
  
  else
  {
    sprintf(tx_buffer, "Comando desconhecido: %s\r\n", cmd);
    send_uart_string(tx_buffer);
  }
}

/**
 * @brief Mostra a configuração de varredura atual
 */
void printConfig(void)
{
  send_uart_string("--- Configuracao Atual ---\r\n");
  sprintf(tx_buffer, "START_FREQ: %lu Hz\r\n", g_start_freq); send_uart_string(tx_buffer);
  sprintf(tx_buffer, "FREQ_INCR:  %lu Hz\r\n", g_freq_incr); send_uart_string(tx_buffer);
  sprintf(tx_buffer, "NUM_INCR:   %d (Max: %d)\r\n", g_num_incr, MAX_INCREMENTS - 1); send_uart_string(tx_buffer);
  sprintf(tx_buffer, "REF_RESIST: %ld Ohm\r\n", g_ref_resist); send_uart_string(tx_buffer);
  send_uart_string("--------------------------\r\n");
}

/**
 * @brief Roda a lógica de calibração (agora usa variáveis globais)
 */
void runCalibration(void)
{
  send_uart_string("Iniciando Calibracao com config atual...\r\n");
  
  // --- GANHO CORRIGIDO PARA X1 ---
  if (!(AD5933::reset() &&
        AD5933::setInternalClock(true) &&
        AD5933::setStartFrequency(g_start_freq) &&  // Usa variável global
        AD5933::setIncrementFrequency(g_freq_incr) && // Usa variável global
        AD5933::setNumberIncrements(g_num_incr) &&   // Usa variável global
        AD5933::setPGAGain(PGA_GAIN_X1))) // <-- CORRIGIDO para X1
  {
    send_uart_string("Falha: Erro na inicializacao do AD5933!\r\n");
    return;
  }
  // --- FIM DA CORREÇÃO ---

  AD5933::setRange(CTRL_OUTPUT_RANGE_1);
  // Usa variáveis globais
  if (AD5933::calibrate(real, imag, gain, phase, g_ref_resist, g_num_incr + 1))
    send_uart_string("Sucesso: AD5933 Calibrado!\r\n");
  else
    send_uart_string("Falha: A calibracao do AD5933 falhou...\r\n");
}

/**
 * @brief Roda a varredura de frequência (Formato "Bonito")
 */
void runSweep(void)
{
  int r_data, i_data, i = 0;
  // Usa variáveis globais
  double cfreq_khz = g_start_freq / 1000.0;
  double freq_incr_khz = g_freq_incr / 1000.0;

  send_uart_string("Iniciando Varredura com config atual...\r\n");
  
  if (!(AD5933::setPowerMode(POWER_STANDBY) &&
        AD5933::setControlMode(CTRL_INIT_START_FREQ) &&
        AD5933::setControlMode(CTRL_START_FREQ_SWEEP)))
  {
    send_uart_string("Nao foi possivel inicializar a varredura...\r\n");
    return;
  }

  while ((AD5933::readStatusRegister() & STATUS_SWEEP_DONE) != STATUS_SWEEP_DONE) 
  {
    if (i > g_num_incr) break; // Usa variável global

    if (!AD5933::getComplexData(&r_data, &i_data)) {
      send_uart_string("Nao foi possivel obter os dados...\r\n");
      continue;
    }

    double magnitude = sqrt(pow((double)r_data, 2) + pow((double)i_data, 2));
    double impedance = 1.0 / (magnitude * gain[i]);
    double faseSistema = (atan2((double)i_data, (double)r_data) * 180.0) / 3.14159;
    double faseReal = faseSistema - phase[i];

    // Formato "Bonito"
    sprintf(tx_buffer, "Freq: %.0f Hz | R: %d | I: %d | Z: %.2f Ohm | Fase: %.2f deg\r\n", 
            (cfreq_khz * 1000), r_data, i_data, impedance, faseReal);
    send_uart_string(tx_buffer);

    i++;
    cfreq_khz += freq_incr_khz;
    AD5933::setControlMode(CTRL_INCREMENT_FREQ);
  }

  send_uart_string("Varredura completa!\r\n");

  if (!AD5933::setPowerMode(POWER_STANDBY))
      send_uart_string("Nao foi possivel entrar em modo standby...\r\n");
}


// -----------------------------------------------------------------
// --- FUNÇÕES DE HARDWARE (PORTADAS DO .INO) ---
// -----------------------------------------------------------------

void send_uart_string(const char* str)
{
  HAL_UART_Transmit(&huart2, (uint8_t*)str, strlen(str), 100);
}

bool setDAC(uint16_t value)
{
  if (value > 4095) value = 4095;
  uint8_t buffer[2];
  buffer[0] = 0x40;
  buffer[0] |= (value >> 8) & 0x0F;
  buffer[1] = value & 0xFF;
  HAL_StatusTypeDef status = HAL_I2C_Master_Transmit(&hi2c1, MCP4725_ADDRESS, buffer, 2, 100);
  return (status == HAL_OK);
}

bool setPot(uint8_t value)
{
  uint8_t buffer[2];
  buffer[0] = AD5252_CMD_RDAC1;
  buffer[1] = value;
  HAL_StatusTypeDef status = HAL_I2C_Master_Transmit(&hi2c1, AD5252_ADDRESS, buffer, 2, 100);
  return (status == HAL_OK);
}

bool setMux1(uint8_t value)
{
  HAL_StatusTypeDef status = HAL_I2C_Master_Transmit(&hi2c1, ADG728_ADDRESS, &value, 1, 100);
  return (status == HAL_OK);
}

bool setMux2(uint8_t value)
{
  send_uart_string("DEBUG: MUX 2 acionado\r\n"); 
  HAL_StatusTypeDef status = HAL_I2C_Master_Transmit(&hi2c1, ADG728_ADDRESS2, &value, 1, 100);
  return (status == HAL_OK);
}


// -----------------------------------------------------------------
// --- LÓGICA DE INTERRUPÇÃO E INICIALIZAÇÃO ---
// -----------------------------------------------------------------

extern "C" void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
  if (huart->Instance == USART2)
  {
    if (rx_byte_it == '\n' || rx_byte_it == '\r')
    {
      if (rx_index > 0) 
      {
        rx_buffer[rx_index] = '\0'; 
        command_ready = true;
        rx_index = 0;
      }
    }
    else 
    {
      if (rx_index < (RX_BUFFER_SIZE - 1)) 
      {
        rx_buffer[rx_index++] = rx_byte_it;
      }
    }
    HAL_UART_Receive_IT(&huart2, &rx_byte_it, 1);
  }
}

extern "C" void USART2_IRQHandler(void)
{
  HAL_UART_IRQHandler(&huart2);
}

extern "C" void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(huart->Instance == USART2)
  {
    __HAL_RCC_USART2_CLK_ENABLE();
    __HAL_RCC_GPIOA_CLK_ENABLE();
    GPIO_InitStruct.Pin = GPIO_PIN_2 | GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
    HAL_NVIC_SetPriority(USART2_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(USART2_IRQn);
  }
}

extern "C" void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(i2cHandle->Instance == I2C1)
  {
    __HAL_RCC_GPIOB_CLK_ENABLE();
    __HAL_RCC_I2C1_CLK_ENABLE();
    GPIO_InitStruct.Pin = GPIO_PIN_8 | GPIO_PIN_9;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  }
}

// --- Funções de Inicialização (Com Diagnóstico) ---

static bool MX_I2C1_Init(void) 
{
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 100000;
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  
  if (HAL_I2C_Init(&hi2c1) != HAL_OK) {
    return false;
  }
  return true; 
}

static void MX_USART2_UART_Init(void)
{
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200; 
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart2) != HAL_OK) { Error_Handler(); }
}

static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  __HAL_RCC_GPIOA_CLK_ENABLE();
  GPIO_InitStruct.Pin = GPIO_PIN_5;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
}

void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2); 
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 16;
  RCC_OscInitStruct.PLL.PLLN = 160;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); }
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) { Error_Handler(); }
}

extern "C" void SysTick_Handler(void) {
  HAL_IncTick();
}

extern "C" void Error_Handler(void)
{
  __disable_irq();
  while (1) {
    HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
    HAL_Delay(100); 
  }
}